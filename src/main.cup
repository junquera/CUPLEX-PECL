import java_cup.runtime.*;
import java.util.HashMap;
import semantic.*;
import java.util.List;
import java.util.ArrayList;

parser code {:

    public SymbolTable tabla = new SymbolTable();
    public ArrayList<SyntaxError> errors = new ArrayList<>();

    public void report_error(String message, Object info) {
        if(info instanceof BASICSymbol) {
            BASICSymbol s = ((BASICSymbol) info);
            errors.add(new SyntaxError(message, s.getLine(), s.getColumn()));
        }

    }

    public void report_fatal_error(String message, Object info) {
        System.err.println("!! FATAL ERROR !!");
        report_error(message, info);
        System.exit(1);
    }
:};

non terminal Node var, var_num_simple, var_num_suscrita, var_cadena;

non terminal Node literal, literal_num;

non terminal Node basic_expression, pow_expression, multiplicative_expression,
                           additive_expression, conditional_expression;

non terminal Node declaracion_dim;

non terminal Node funcion_suministrada, funcion;


non terminal /*Node.Programa*/ Node.Programa programa;
non terminal /*Node.Line*/ List<Node.Linea> lineas;
non terminal /*Node.Linea*/ Node.Linea linea;
non terminal /*Node.Sentencia*/ Node sentencia, asignacion, goto, if_then, gosub, on_goto, stop, for_to, next, print, input, def_funcion_nueva, data, read, dim;

terminal POW, MUL, DIV, SUM, SUB, EQU, COMA, PCOMA,
         LT, LE, GE, GT, NEQ, DATA, DEF, DIM, END, FOR, GO,
         GOSUB, GOTO, IF, INPUT, LET, NEXT, ON, PRINT, RANDOMIZE,
         READ, REM, RESTORE, RETURN, STEP, STOP, THEN, TO, ABS, ATN, INT,
         COS, EXP, LOG, RND, SGN, SIN, SQR, TAN, FN, VAR_NUM, VAR_TXT,
         LPAR, RPAR, ERROR, CRLF;

terminal Integer INTEGER;
terminal Float FLOAT;
terminal String STRING;

// TODO Hay que ver si esto se puede poner (segun PECL)
start with programa;

programa ::= lineas:ls {:
    Node.Programa p = new Node.Programa();
    for(Node.Linea nl: ls)
        p.addSonNode(nl);
    p.check();
    System.out.println(p.getTree());
    RESULT = p;
:};

lineas ::=  linea:l {:
                List<Node.Linea> lineas = new ArrayList<>();
                Node.Linea linea = (Node.Linea) l;
                lineas.add(linea);
                RESULT = lineas;
             :} |
             lineas:ls linea:l {:
                List<Node.Linea> lineas = ls;
                Node.Linea linea = (Node.Linea) l;
                lineas.add(linea);
                RESULT = lineas;
            :};

linea ::= INTEGER:i sentencia:s CRLF {:
              Node.Linea nl = new Node.Linea(i);
              nl.addSonNode(s);
              RESULT = nl;
          :};

sentencia ::=  asignacion | goto | if_then | gosub |
               on_goto| stop| for_to | next | print | input | data |
               def_funcion_nueva | read | dim | REM | RANDOMIZE | RESTORE | END ;


/** ES1.- Variables **/
var ::= var_num_simple:v {: RESULT = v; :} |
        var_cadena:v {: RESULT = v; :} |
        var_num_suscrita:v {: RESULT = v; :}
        ;

var_num_simple ::= VAR_NUM:v {:
                        Node.Variable va = new Node.Variable(v, Node.Variable.NUMERIC);
                        RESULT = va;
                    :};

// TODO VariableDim
var_num_suscrita ::= VAR_NUM:v LPAR literal_num:v1 RPAR {:
                            Node.Variable va = new Node.Variable(v, Node.Variable.NUMERIC);
                            va.addSonNode(v1);
                            RESULT = va;
                    :} |
                    VAR_NUM:v LPAR literal_num:v1 COMA literal_num:v2 RPAR {:
                              Node.Variable va = new Node.Variable(v, Node.Variable.NUMERIC);
                              va.addSonNode(v1);
                              va.addSonNode(v2);
                              RESULT = va;
                      :};

var_cadena ::= VAR_TXT:v {:
                    Node.Variable va = new Node.Variable(v, Node.Variable.STRING);
                    RESULT = va;
                :};

/** ES2.- Expresiones numéricas **/

literal ::= literal_num:v {:
                RESULT = v;
            :} |
            STRING:v {:
                RESULT = new Node.Literal(v, Node.Variable.STRING);
            :}
            ;

literal_num ::= INTEGER:v {:
                     RESULT = new Node.Literal(v, Node.Variable.NUMERIC);
                :}| FLOAT:v {:
                    RESULT = new Node.Literal(v, Node.Variable.NUMERIC);
                 :};

basic_expression ::= literal:e {:
                        RESULT = e;
                   :} |
                    var:e {:
                          RESULT = e;
                     :} |
                   LPAR basic_expression:b RPAR {:
                        RESULT = b;
                    :};

pow_expression ::= basic_expression:e {:
                        RESULT = e;
                   :} |
                   pow_expression:e1 POW basic_expression:e2 {:
                      Node.BinExpression be = new Node.BinExpression(Node.BinExpression.POW);
                      be.addSonNode(e1);
                      be.addSonNode(e2);
                      RESULT = be;
                   :};

multiplicative_expression ::=
		pow_expression:e {:
              RESULT = e;
         :} |
		multiplicative_expression:e1 DIV basic_expression:e2 {:
              Node.BinExpression be = new Node.BinExpression(Node.BinExpression.DIV);
              be.addSonNode(e1);
              be.addSonNode(e2);
              RESULT = be;
       :} |
       multiplicative_expression:e1 MUL basic_expression:e2 {:
              Node.BinExpression be = new Node.BinExpression(Node.BinExpression.MUL);
              be.addSonNode(e1);
              be.addSonNode(e2);
              RESULT = be;
       :};

additive_expression ::=
		multiplicative_expression:e {:
             RESULT = e;
        :}
	|	additive_expression:e1 SUM multiplicative_expression:e2 {:
              Node.BinExpression be = new Node.BinExpression(Node.BinExpression.SUM);
              be.addSonNode(e1);
              be.addSonNode(e2);
              RESULT = be;
       :}
	|	additive_expression:e1 SUB multiplicative_expression:e2 {:
              Node.BinExpression be = new Node.BinExpression(Node.BinExpression.SUB);
              be.addSonNode(e1);
              be.addSonNode(e2);
              RESULT = be;
       :}
	;

/** ES3.- Funciones suministradas**/

funcion_suministrada ::= ABS LPAR funcion_suministrada:f RPAR {:
                            Node.Funcion nf = new Node.Funcion("ABS");
                            nf.addSonNode(f);
                            RESULT = nf;
                        :} |
                        ATN LPAR funcion_suministrada:f RPAR {:
                            Node.Funcion nf = new Node.Funcion("ATN");
                            nf.addSonNode(f);
                            RESULT = nf;
                         :} |
                         COS LPAR funcion_suministrada:f RPAR {:
                            Node.Funcion nf = new Node.Funcion("COS");
                            nf.addSonNode(f);
                            RESULT = nf;
                         :} |
                         EXP LPAR funcion_suministrada:f RPAR {:
                            Node.Funcion nf = new Node.Funcion("EXP");
                            nf.addSonNode(f);
                            RESULT = nf;
                         :} |
                         INT LPAR funcion_suministrada:f RPAR {:
                            Node.Funcion nf = new Node.Funcion("INT");
                            nf.addSonNode(f);
                            RESULT = nf;
                         :} |
                         LOG LPAR funcion_suministrada:f RPAR {:
                            Node.Funcion nf = new Node.Funcion("LOG");
                            nf.addSonNode(f);
                            RESULT = nf;
                         :} |
                         SGN LPAR funcion_suministrada:f RPAR {:
                            Node.Funcion nf = new Node.Funcion("SGN");
                            nf.addSonNode(f);
                            RESULT = nf;
                         :} |
                         SIN LPAR funcion_suministrada:f RPAR {:
                            Node.Funcion nf = new Node.Funcion("SIN");
                            nf.addSonNode(f);
                            RESULT = nf;
                         :} |
                         SQR LPAR funcion_suministrada:f RPAR {:
                            Node.Funcion nf = new Node.Funcion("SQR");
                            nf.addSonNode(f);
                            RESULT = nf;
                         :} |
                         TAN LPAR funcion_suministrada:f RPAR {:
                            Node.Funcion nf = new Node.Funcion("TAN");
                            nf.addSonNode(f);
                            RESULT = nf;
                         :} |
                         RND {:
                            Node.Funcion nf = new Node.Funcion("RND");
                            RESULT = nf;
                        :}  |
                         additive_expression:e {:
                            RESULT = e;
                         :}
                         ;


/** ES4.- Nuevas funciones **/

def_funcion_nueva ::= DEF FN:f VAR_NUM:v EQU funcion:fn {:
        Node.DefFuncion ndf = new Node.DefFuncion();
        Node.Funcion nf = new Node.Funcion((String) f + (String) v, true);
        ndf.addSonNode(nf);
        ndf.addSonNode(fn);
        RESULT = ndf;
    :} |
    DEF FN:f VAR_NUM:v LPAR funcion:fn1 RPAR EQU funcion:fn2 {:
        Node.DefFuncion ndf = new Node.DefFuncion();
        Node.Funcion nf = new Node.Funcion((String) f + (String) v, true);
        nf.addSonNode(fn1);
        ndf.addSonNode(nf);
        ndf.addSonNode(fn2);
        RESULT = ndf;
    :}
;

// TODO Cómo hacer funcion + X ?
funcion ::= FN:f VAR_NUM:v {:
                Node.Funcion nf = new Node.Funcion((String) f + (String) v, true);
                RESULT = nf;
            :} | FN:f VAR_NUM:v LPAR funcion:fe RPAR {:
                Node.Funcion nf = new Node.Funcion((String) f + (String) v, true);
                nf.addSonNode(fe);
                RESULT = nf;
            :}  | funcion_suministrada:fs {:
                RESULT = fs;
            :};


/** ES5.- Asignacion **/

asignacion ::= LET var:v EQU funcion:f {:
    Node.Asignacion na = new Node.Asignacion();
    na.addSonNode(v);
    na.addSonNode(f);
    RESULT = na;
 :};

/** ES6.- Comparacion **/
conditional_expression ::=  conditional_expression:e1 LT funcion:e2 {:
                                   Node.CondExpression be = new Node.CondExpression(Node.CondExpression.LT);
                                   be.addSonNode(e1);
                                   be.addSonNode(e2);
                                   RESULT = be;
                            :} |
                            conditional_expression:e1 LE funcion:e2 {:
                                    Node.CondExpression be = new Node.CondExpression(Node.CondExpression.LE);
                                    be.addSonNode(e1);
                                    be.addSonNode(e2);
                                    RESULT = be;
                             :} |
                            conditional_expression:e1 GE funcion:e2  {:
                                  Node.CondExpression be = new Node.CondExpression(Node.CondExpression.GE);
                                  be.addSonNode(e1);
                                  be.addSonNode(e2);
                                  RESULT = be;
                           :} |
                            conditional_expression:e1 GT funcion:e2  {:
                                  Node.CondExpression be = new Node.CondExpression(Node.CondExpression.GT);
                                  be.addSonNode(e1);
                                  be.addSonNode(e2);
                                  RESULT = be;
                           :} |
                            conditional_expression:e1 EQU funcion:e2 {:
                                  Node.CondExpression be = new Node.CondExpression(Node.CondExpression.EQU);
                                  be.addSonNode(e1);
                                  be.addSonNode(e2);
                                  RESULT = be;
                           :} |
                            conditional_expression:e1 NEQ funcion:e2  {:
                                   Node.CondExpression be = new Node.CondExpression(Node.CondExpression.NEQ);
                                   be.addSonNode(e1);
                                   be.addSonNode(e2);
                                   RESULT = be;
                            :} |
                            funcion:f {:
                                RESULT = f;
                            :}
                            ;

/** ES7.- Sentencias de control**/

goto ::= GOTO INT;

// TODO conditional_expression == exp1 comparación exp2
if_then ::= IF conditional_expression THEN INTEGER |
            IF conditional_expression THEN error:e {:
                parser.report_error("SyntaxError en if: IF c THEN (numero de linea)", e);
            :} |
            IF error:e {:
                parser.report_error("SyntaxError en if: ", e);
            :};

gosub ::= GOSUB INTEGER lineas RETURN;

on_goto ::= ON conditional_expression GOTO |
            on_goto COMA INTEGER;

stop ::= STOP; // TRATAR COMO GOTO END

/** ES8.- For-To **/
for_to ::= FOR var EQU funcion TO funcion |
           FOR var EQU funcion TO funcion STEP funcion
           ;

next ::= NEXT var;


/** ES9.- PrINTEGER */

print ::= PRINT funcion |
          print PCOMA funcion |
          print COMA funcion
          ;


/** ES10.- Input **/

input ::= INPUT var |
          input COMA var |
          INPUT error:e {:
            parser.report_error("SyntaxError en input: ", e);
          :}
          ;

/** ES11.- Data**/
data ::= DATA funcion |
         data COMA funcion |
         DATA error:e {:
            parser.report_error("SyntaxError en data: ", e);
         :}
         ;


/** ES12.- Read **/

read ::= READ var |
         read COMA var |
         READ error:e {:
             parser.report_error("SyntaxError en read: ", e);
         :}
         ;


/** ES13.- Dim **/
// TODO Revisar esto
declaracion_dim ::= VAR_NUM LPAR INTEGER RPAR |
                    VAR_NUM LPAR INTEGER COMA INTEGER RPAR |
                    VAR_NUM LPAR error:e RPAR {:
                        parser.report_error("Hay que introducir un entero; o dos separados por comas (','): ", e);
                    :};

dim ::= DIM declaracion_dim
        | dim COMA declaracion_dim
        ;


/** ES14.- Rem **/
/** ES15.- Randomize **/

