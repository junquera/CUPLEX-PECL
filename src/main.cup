import java_cup.runtime.*;

parser code {:
    public void report_error(String message, Object info) {
        StringBuffer m = new StringBuffer("Error");
        System.out.println("Mensaje: " + message);
        System.out.println("info: " + info.toString());
        if(info instanceof java_cup.runtime.Symbol){
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if(s.left >= 0){
                m.append(" en la linea " + (s.left + 1));
                if (s.right >= 0)
                    m.append(", y columna " + (s.right + 1));
            }
        }
        m.append(" : " + message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};

non terminal var, var_num_simple, var_num_suscrita, var_cadena, literal, literal_num, basic_expression, pow_expression, multiplicative_expression, additive_expression, funcion_suministrada, def_funcion_nueva, funcion, asignacion, conditional_expression, goto, if_then, gosub, on_goto, stop, for_to, print, input, data, read, restore, declaracion_dim, dim, rem, randomize;
non terminal programa, lineas, sentencia;

terminal POW, MUL, DIV, SUM, SUB, EQU, COMA, PCOMA,
         LT, LE, GE, GT, NEQ, DATA, DEF, DIM, END, FOR, GO,
         GOSUB, GOTO, IF, INPUT, LET, NEXT, ON, PRINT, RANDOMIZE,
         READ, REM, RESTORE, RETURN, STEP, STOP, THEN, TO, ABS, ATN, INT,
         COS, EXP, LOG, RND, SGN, SIN, SQR, TAN, FN, VAR_NUM, VAR_TXT,
         LPAR, RPAR, ERROR;

terminal Integer INTEGER;
terminal Float FLOAT;
terminal String STRING;

programa ::= lineas INTEGER END;
// TODO \n?
lineas ::= INTEGER sentencia | lineas INTEGER sentencia;

sentencia ::=  asignacion | goto | if_then | gosub |
               on_goto| stop| for_to | print | input | def_funcion_nueva |
               data | read | dim | rem | randomize ;


/** ES1.- Variables **/
var ::= var_num_simple |
        var_cadena |
        var_num_suscrita
        ;

var_num_simple ::= VAR_NUM;
var_num_suscrita ::= VAR_NUM LPAR literal_num RPAR | VAR_NUM LPAR literal_num COMA literal_num RPAR;
var_cadena ::= VAR_TXT:v ;

/** ES2.- Expresiones numéricas **/

literal ::= literal_num
            | STRING
            ;

literal_num ::= INTEGER | FLOAT;

basic_expression ::= literal
                       | var
                       | LPAR basic_expression RPAR
                       ;

pow_expression ::= basic_expression
                   | pow_expression POW basic_expression
                   ;

multiplicative_expression ::=
		pow_expression
	|	multiplicative_expression MUL basic_expression
	|	multiplicative_expression DIV basic_expression
	;

additive_expression ::=
		multiplicative_expression
	|	additive_expression SUM multiplicative_expression
	|	additive_expression SUB multiplicative_expression
	;

/** ES3.- Funciones suministradas**/

funcion_suministrada ::= ABS LPAR funcion_suministrada RPAR
                         | ATN LPAR funcion_suministrada RPAR
                         | COS LPAR funcion_suministrada RPAR
                         | EXP LPAR funcion_suministrada RPAR
                         | INT LPAR funcion_suministrada RPAR
                         | LOG LPAR funcion_suministrada RPAR
                         | SGN LPAR funcion_suministrada RPAR
                         | SIN LPAR funcion_suministrada RPAR
                         | SQR LPAR funcion_suministrada RPAR
                         | TAN LPAR funcion_suministrada RPAR
                         | RND
                         | additive_expression
                         ;


/** ES4.- Nuevas funciones **/

def_funcion_nueva ::= DEF FN VAR_NUM EQU additive_expression |
                  DEF FN VAR_NUM LPAR VAR_NUM RPAR EQU additive_expression
                  ;

funcion ::= FN VAR_NUM | FN VAR_NUM LPAR funcion RPAR | funcion_suministrada;

// TODO Cómo hacer funcion + X ?

/** ES5.- Asignacion **/

asignacion ::= LET var EQU funcion ;

/** ES6.- Comparacion **/

conditional_expression ::=  conditional_expression LT funcion |
                            conditional_expression LE funcion |
                            conditional_expression GE funcion |
                            conditional_expression GT funcion |
                            conditional_expression EQU funcion |
                            conditional_expression NEQ funcion |
                            funcion
                            ;

/** ES7.- Sentencias de control**/

goto ::= GOTO INT;

// TODO conditional_expression == exp1 comparación exp2
if_then ::= IF conditional_expression THEN INTEGER | IF error:e {:
    parser.report_error("" + eleft, e);
:};

gosub ::= GOSUB INTEGER lineas RETURN;

on_goto ::= ON conditional_expression GOTO |
            on_goto COMA INTEGER;

stop ::= STOP; // TRATAR COMO GOTO END

/** ES8.- For-To **/
for_to ::= FOR var EQU funcion TO  funcion lineas INTEGER NEXT var|
           FOR var EQU funcion TO  funcion STEP funcion lineas INTEGER NEXT var
           ;


/** ES9.- PrINTEGER */

print ::= PRINT funcion |
          print PCOMA funcion |
          print COMA funcion
          ;


/** ES10.- Input **/

input ::= INPUT var |
          input COMA var
          ;

/** ES11.- Data**/

data ::= DATA basic_expression |
         data COMA basic_expression;


/** ES12.- Read **/

read ::= READ var |
         read COMA var
         ;

restore ::= RESTORE;


/** ES13.- Dim **/
declaracion_dim ::= INTEGER LPAR INTEGER RPAR | INTEGER LPAR INTEGER COMA INTEGER RPAR;

dim ::= DIM declaracion_dim
        | dim COMA declaracion_dim
        ;


/** ES14.- Rem **/

rem ::= REM;

/** ES15.- Randomize **/

randomize ::= RANDOMIZE;


