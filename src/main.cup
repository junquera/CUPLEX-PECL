import java_cup.runtime.*;
import java.util.HashMap;
import semantic.*;

parser code {:

    public SymbolTable tabla = new SymbolTable();


    public void report_error(String message, Object info) {
        StringBuffer m = new StringBuffer("Error");
        System.out.println("Mensaje: " + message);
        // System.out.println("info: " + info.toString());
        if(info instanceof java_cup.runtime.Symbol){
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if(s.left > 0){
                m.append(" en la linea " + (s.left));
                if (s.right > 0)
                    m.append(", y columna " + (s.right));
            }
        }
        m.append(" : " + message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        System.out.println("FATAL ERROR");
        report_error(message, info);
        System.exit(1);
    }
:};

non terminal Variable var;
non terminal VarNumSimple var_num_simple;
non terminal VarNumSuscrita var_num_suscrita;
non terminal VarCadena var_cadena;

non terminal literal, literal_num,
             basic_expression, pow_expression, multiplicative_expression, additive_expression, conditional_expression,
             declaracion_dim;

non terminal Funcion funcion_suministrada, funcion,


non terminal Programa programa;
non terminal Linea[] lineas;
non terminal Linea linea;
non terminal Sentencia sentencia, asignacion, goto, if_then, gosub, on_goto, stop, for_to, print, input, def_funcion_nueva, data, read, dim, rem, restore, randomize;

terminal POW, MUL, DIV, SUM, SUB, EQU, COMA, PCOMA,
         LT, LE, GE, GT, NEQ, DATA, DEF, DIM, END, FOR, GO,
         GOSUB, GOTO, IF, INPUT, LET, NEXT, ON, PRINT, RANDOMIZE,
         READ, REM, RESTORE, RETURN, STEP, STOP, THEN, TO, ABS, ATN, INT,
         COS, EXP, LOG, RND, SGN, SIN, SQR, TAN, FN, VAR_NUM, VAR_TXT,
         LPAR, RPAR, ERROR;

terminal Integer INTEGER;
terminal Float FLOAT;
terminal String STRING;

// TODO Hay que ver si esto se puede poner (segun PECL)
start with programa;

programa ::= lineas INTEGER END;
// TODO \n?
lineas ::= linea | lineas linea;

linea ::= INTEGER sentencia;

sentencia ::=  asignacion | goto | if_then | gosub |
               on_goto| stop| for_to | print | input | def_funcion_nueva |
               data | read | dim | rem | randomize ;


/** ES1.- Variables **/
var ::= var_num_simple:v {:
            RESULT = v;
        :} |
        var_cadena:v {:
          RESULT = v;
        :} |
        var_num_suscrita:v {:
            RESULT = v;
        :};

var_num_simple ::=  VAR_NUM:v {:
                      RESULT = new VarNumSimple((String) v, null);
                    :};

var_num_suscrita ::= VAR_NUM LPAR literal_num RPAR:v {:
                        RESULT = new VarNumSuscrita((String) v, null);
                     :} |
                     VAR_NUM LPAR literal_num COMA literal_num RPAR:v {:
                        RESULT = new VarNumSuscrita2((String) v, null);
                    :};

var_cadena ::=  VAR_TXT:v {:
                  RESULT = new VarCadena((String) v, null);
                :};

/** ES2.- Expresiones numéricas **/
literal ::= literal_num:l {:
                RESULT = l;
            :} |
            STRING:s {:
                RESULT = s;
            :};

literal_num ::= INTEGER:i {:
                    RESULT = new Integer(i);
                :} |
                FLOAT:f {:
                    RESULT = new Float(f);
                :};

basic_expression ::=   literal:l {:
                            RESULT = l;
                        :} |
                        var:v {:
                            // TODO Valor de tabla de simbolos
                            RESULT = parser.tabla.get(v.getName());
                       :} |
                       LPAR basic_expression:b RPAR {:
                            RESULT = b;
                       :};

pow_expression ::= basic_expression:b {:
                        RESULT = b;
                   :} |
                   pow_expression:p POW:s basic_expression:b {: RESULT =  Math.pow(p, b); :}
                   ;

multiplicative_expression ::=
		pow_expression:p {: RESULT =  :}
	|	multiplicative_expression:m MUL basic_expression:b {: RESULT = m*b;  :}
	|	multiplicative_expression:m DIV basic_expression:b {: RESULT = m/b :}
	;

additive_expression ::=
		multiplicative_expression:m {: RESULT = m; :}
	|	additive_expression:a SUM multiplicative_expression:m {: RESULT = a + m; :}
	|	additive_expression:a SUB multiplicative_expression:m {: RESULT = a - m :}
	;

/** ES3.- Funciones suministradas**/

funcion_suministrada ::= ABS LPAR funcion_suministrada:f RPAR {: RESULT = f;  :}
                         | ATN LPAR funcion_suministrada:f RPAR {: RESULT = f; :}
                         | COS LPAR funcion_suministrada:f RPAR {: RESULT = f; :}
                         | EXP LPAR funcion_suministrada:f RPAR {: RESULT = f; :}
                         | INT LPAR funcion_suministrada:f RPAR {: RESULT = f; :}
                         | LOG LPAR funcion_suministrada:f RPAR {: RESULT = f; :}
                         | SGN LPAR funcion_suministrada:f RPAR {: RESULT = f; :}
                         | SIN LPAR funcion_suministrada:f RPAR {: RESULT = f; :}
                         | SQR LPAR funcion_suministrada:f RPAR {: RESULT = f; :}
                         | TAN LPAR funcion_suministrada:f RPAR {: RESULT = f; :}
                         | RND
                         | additive_expression:a {: RESULT = a; :}
                         ;


/** ES4.- Nuevas funciones **/

def_funcion_nueva ::= DEF FN VAR_NUM EQU additive_expression |
                  DEF FN VAR_NUM LPAR VAR_NUM RPAR EQU additive_expression
                  ;

funcion ::= FN VAR_NUM | FN VAR_NUM LPAR funcion RPAR | funcion_suministrada;

// TODO Cómo hacer funcion + X ?

/** ES5.- Asignacion **/

asignacion ::= LET var:v EQU funcion:f {:

:};
//
//    EXAMPLE OF "ESm 2-3.-"
//
//    switch (((Symbol) v).sym){
//        case sym.VAR_TXT:
//            if(((Symbol) f).sym != sym.STRING){
//                System.out.println(((Symbol) f).sym  + " " + ((Symbol) v).sym);
//                throw new Exception();
//            }
//            break;
//        case sym.VAR_NUM:
//            int aux = ((Symbol) f).sym;
//            if(aux != sym.INTEGER && aux != sym.FLOAT){
//                System.out.println(aux + " " + ((Symbol) v).sym);
//                throw new Exception();
//            }
//            break;
//        default:
//            throw new Exception();
//    }

/** ES6.- Comparacion **/

conditional_expression ::=  conditional_expression LT funcion |
                            conditional_expression LE funcion |
                            conditional_expression GE funcion |
                            conditional_expression GT funcion |
                            conditional_expression EQU funcion |
                            conditional_expression NEQ funcion |
                            funcion
                            ;

/** ES7.- Sentencias de control**/

goto ::= GOTO INT;

// TODO conditional_expression == exp1 comparación exp2
if_then ::= IF conditional_expression THEN INTEGER |
            IF conditional_expression THEN error:e {:
                parser.report_error("Error en if: IF c THEN (numero de linea)", e);
            :} |
            IF error:e {:
                parser.report_error("Error en if: ", e);
            :};

gosub ::= GOSUB INTEGER lineas RETURN;

on_goto ::= ON conditional_expression GOTO |
            on_goto COMA INTEGER;

stop ::= STOP; // TRATAR COMO GOTO END

/** ES8.- For-To **/
for_to ::= FOR var EQU funcion TO  funcion lineas INTEGER NEXT var|
           FOR var EQU funcion TO  funcion STEP funcion lineas INTEGER NEXT var
           ;


/** ES9.- PrINTEGER */

print ::= PRINT funcion |
          print PCOMA funcion |
          print COMA funcion
          ;


/** ES10.- Input **/

input ::= INPUT var |
          input COMA var
          ;

/** ES11.- Data**/

data ::= DATA basic_expression |
         DATA error:e {:
            parser.report_error("Error en data: ", e);
         :} |
         data COMA basic_expression;


/** ES12.- Read **/

read ::= READ var |
         READ error:e {:
             parser.report_error("Error en read: ", e);
         :} |
         read COMA var
         ;

restore ::= RESTORE;


/** ES13.- Dim **/
// TODO Revisar esto
declaracion_dim ::= VAR_NUM LPAR INTEGER RPAR |
                    VAR_NUM LPAR INTEGER COMA INTEGER RPAR |
                    VAR_NUM LPAR error:e RPAR {:
                        parser.report_error("Hay que introducir un entero; o dos separados por comas (','): ", e);
                    :};

dim ::= DIM declaracion_dim
        | dim COMA declaracion_dim
        ;


/** ES14.- Rem **/

rem ::= REM;

/** ES15.- Randomize **/

randomize ::= RANDOMIZE;


