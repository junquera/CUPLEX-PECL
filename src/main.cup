import java_cup.runtime.*;

parser code {:
    public void report_error(String message, Object info) {
        StringBuffer m = new StringBuffer("Error");
        System.out.println("Mensaje: " + message);
        System.out.println("info: " + info.toString());
        if(info instanceof java_cup.runtime.Symbol){
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if(s.left >= 0){
                m.append(" en la linea " + (s.left + 1));
                if (s.right >= 0)
                    m.append(", y columna " + (s.right + 1));
            }
        }
        m.append(" : " + message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};

non terminal var, var_num_simple, var_num_suscrita, var_cadena, literal, literal_num, postfix_expression, pow_expression, multiplicative_expression, additive_expression, funcion_suministrada, funcion_nueva, asignacion, conditional_expression, goto, if_then, gosub, on_goto, stop, for_to, print, input, data, read, restore, declaracion_dim, dim, rem, randomize;
non terminal programa, lineas, sentencia;

terminal POW, MUL, DIV, SUM, SUB, EQU, COMA, PCOMA,
         LT, LE, GE, GT, NEQ, DATA, DEF, DIM, END, FOR, GO,
         GOSUB, GOTO, IF, INPUT, LET, NEXT, ON, PRINT, RANDOMIZE,
         READ, REM, RESTORE, RETURN, STEP, STOP, THEN, TO, ABS, ATN, INT,
         COS, EXP, LOG, RND, SGN, SIN, SQR, TAN, FN, VAR_NUM, VAR_TXT,
         LPAR, RPAR, ERROR;

terminal Integer INTEGER;
terminal Float FLOAT;
terminal String STRING;

programa ::= lineas INTEGER END;
// TODO \n
lineas ::= INTEGER sentencia | lineas INTEGER sentencia;

sentencia ::=  asignacion | goto | if_then | gosub |
               on_goto| stop| for_to | print | input |
               data | read | dim | rem | randomize ;


/** ES1.- Variables **/
var ::= var_num_simple |
        var_cadena |
        var_num_suscrita
        ;

var_num_simple ::= VAR_NUM;
var_num_suscrita ::= VAR_NUM LPAR literal_num RPAR | VAR_NUM LPAR literal_num COMA literal_num RPAR;
var_cadena ::= VAR_TXT:v ;

/** ES2.- Expresiones numéricas **/

literal ::= literal_num
            | STRING
            ;

literal_num ::= INTEGER | FLOAT;

postfix_expression ::= literal
                       | var
                       | LPAR postfix_expression RPAR
                       ;

pow_expression ::= postfix_expression
                   | pow_expression POW postfix_expression
                   ;

multiplicative_expression ::=
		pow_expression
	|	multiplicative_expression MUL postfix_expression
	|	multiplicative_expression DIV postfix_expression
	;

additive_expression ::=
		multiplicative_expression
	|	additive_expression SUM multiplicative_expression
	|	additive_expression SUB multiplicative_expression
	;

/** ES3.- Funciones suministradas**/

funcion_suministrada ::= ABS LPAR additive_expression RPAR
                         | ATN LPAR additive_expression RPAR
                         | COS LPAR additive_expression RPAR
                         | EXP LPAR additive_expression RPAR
                         | INT LPAR additive_expression RPAR
                         | LOG LPAR additive_expression RPAR
                         | SGN LPAR additive_expression RPAR
                         | SIN LPAR additive_expression RPAR
                         | SQR LPAR additive_expression RPAR
                         | TAN LPAR additive_expression RPAR
                         | RND
                         ;


/** ES4.- Nuevas funciones **/
// TODO funcion_nueva - def_funcion_nueva

funcion_nueva ::= DEF FN VAR_NUM EQU additive_expression |
                  DEF FN VAR_NUM LPAR VAR_NUM RPAR EQU additive_expression
                  ;


/** ES5.- Asignacion **/

asignacion ::= LET var EQU additive_expression ;

/** ES6.- Comparacion **/

conditional_expression ::=  conditional_expression LT additive_expression |
                            conditional_expression LE additive_expression |
                            conditional_expression GE additive_expression |
                            conditional_expression GT additive_expression |
                            conditional_expression EQU additive_expression |
                            conditional_expression NEQ additive_expression |
                            additive_expression
                            ;

/** ES7.- Sentencias de control**/

goto ::= GOTO INT;

// TODO conditional_expression == exp1 comparación exp2
if_then ::= IF conditional_expression THEN INTEGER ;

gosub ::= GOSUB INTEGER lineas RETURN;

on_goto ::= ON conditional_expression GOTO |
            on_goto COMA INTEGER;

stop ::= STOP; // TRATAR COMO GOTO END

/** ES8.- For-To **/

for_to ::= FOR var EQU additive_expression TO  additive_expression lineas NEXT var|
           FOR var EQU additive_expression TO  additive_expression STEP additive_expression lineas NEXT var
           ;


/** ES9.- PrINTEGER */

print ::= PRINT additive_expression |
          print PCOMA additive_expression |
          print COMA additive_expression
          ;


/** ES10.- Input **/

input ::= INPUT var |
          input COMA var
          ;

/** ES11.- Data**/

data ::= DATA postfix_expression |
         data COMA postfix_expression;


/** ES12.- Read **/

read ::= READ var |
         read COMA var
         ;

restore ::= RESTORE;


/** ES13.- Dim **/
declaracion_dim ::= INTEGER LPAR INTEGER RPAR | INTEGER LPAR INTEGER COMA INTEGER RPAR;

dim ::= DIM declaracion_dim
        | dim COMA declaracion_dim
        ;


/** ES14.- Rem **/

rem ::= REM;

/** ES15.- Randomize **/

randomize ::= RANDOMIZE;


