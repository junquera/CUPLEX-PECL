import java_cup.runtime.*;
import java.util.*;
import java.io.*;

parser code {:
	public static void main (String argv[]) throws Exception {
		parser analizador;
		analizador = new parser(new Yylex(new FileReader(new File("test.txt"))));
		try{
			analizador.parse();
		} catch(Exception se){
			System.err.println("Hay un error semántico:\n" + se.getMessage());
		}
	}

:};

// TODO Averiguar qué significan "skip" y "<>"
terminal PROGRAM, IS, BEGIN, END;
terminal VAR, IS_INTEGER, IS_BOOLEAN;
terminal READ, WRITE;
terminal SKIP;
terminal REPEAT, UNTIL;
terminal IF, THEN, ELSE;
terminal AND, OR, NOT;
terminal ASIGNACION;
terminal MINOR_EQUAL, MINOR, EQUAL, MAJOR, MAJOR_EQUAL, MINOR_MAJOR;
terminal SUMA, RESTA, MULTIPLICACION, DIVISION;
terminal LPARENT, RPARENT, COMA, SEMI_COLON, COLON;
terminal INTEGER, BOOLEAN, IDENTIFIER;

non terminal var_init_identifiers;
non terminal var_type;

non terminal Programa programa;
non terminal VarList var_init_list;
non terminal StatementList statement_list;

non terminal Statement statement;
non terminal Condition cond;
non terminal Expression expr;

// TODO ¿Intentar evaluar precedencia gramaticalmente?
precedence left MULTIPLICACION, DIVISION, SUMA, RESTA;
precedence left AND, OR;


programa ::= PROGRAM IDENTIFIER:id IS
                var_init_list:var_list
             BEGIN
                statement_list:stmt_list
             END {:
                var_init_list.put(id, new PseudoIdentifier(id));
                Programa p = new Programa(var_init_list, statement_list);
             :};

var_init_list ::= var_init_list:identifiers VAR var_init_identifiers:id_list COLON var_type:type SEMI_COLON {:
                    if(type == 0){
                        for(String identifier: id_list){
                            identifiers.put(identifier, new IntegerIdentifier(identifier, value));
                        }
                    } else if (type == 1){
                        for(String identifier: id_list){
                            identifiers.put(identifier, new BooleanIdentifier(identifier, value));
                        }
                    } else {
                        throw new Exception(String.format("Var type %d is not allowed.", type));
                    }
                    RESULT = identifiers;
                :}
                | {: RESULT = new VarList(); :} // Void => Init var list
                ;

var_type ::= IS_INTEGER {: RESULT = 0; :} | IS_BOOLEAN {: RESULT = 1; :};

var_init_identifiers ::= var_init_identifiers:id_list COMA IDENTIFIER:id {:
                            id_list.add(id);
                            RESULT = id_list;
                        :}
                       | VAR IDENTIFIER:id {:
                            ArrayList<String> identifiers = new ArrayList<>();
                            identifiers.add(id);
                            RESULT = identifiers;
                       :};

statement_list ::= statement_list:stmt_list statement:stmt {:
                    stmt_list.add(stmt);
                    RESULT = stmt_list;
                 :}
                 | statement:stmt {:
                    StatementList stmtList = StatementList();
                    stmtList.add(stmt);
                 :};
statement ::= IDENTIFIER:i ASIGNACION expr:e SEMI_COLON
            {:
              RESULT = new IdentifierStatement(id, e);
            :}
            | IDENTIFIER:i ASIGNACION cond:c SEMI_COLON
            {:
              RESULT = new IdentifierStatement(id, c);
            :}
            | IF cond:c THEN statement_list:stmnt END IF SEMI_COLON
            {:
              RESULT = new IfStatement(c, stmnt);
            :}
            | IF cond:c THEN statement_list:ifStmnt ELSE statement_list:elseStmnt END IF SEMI_COLON // TODO Ver else ambiguo
            {:
              RESULT = new IfStatement(c, ifStmnt, elseStmnt);
            :}
            | REPEAT statement_list:stmnt UNTIL cond:c SEMI_COLON
            {:
              RESULT = new RepeatStatement(c, stmnt);
            :}
            | WRITE expr:e {: RESULT = new WriteStatement(e); :}
            | READ IDENTIFIER:i {: RESULT = new ReadStatement(i); :}
            ;

cond ::= NOT cond:c {: RESULT = new NotCondition(c); :}
       | LPARENT cond:c RPARENT {: RESULT = c; :}
       | cond:c1 AND cond:c2 {: RESULT = new AndCondition(c1, c2); :}
       | cond:c1 OR cond:c2 {: RESULT = new OrCondition(c1, c2); :}
       | expr:e1 EQUAL expr:e2 {: RESULT = new EqualCondition(e1, e2); :}        // ¿También 'cond EQUAL cond'?
       | expr:e1 MINOR_EQUAL expr:e2 {: RESULT = new MinorEqualCondition(e1, e2); :}
       | expr:e1 MINOR expr:e2 {: RESULT = new MinorCondition(e1, e2); :}
       | expr:e1 MAJOR expr:e2 {: RESULT = new MajorCondition(e1, e2); :}
       | expr:e1 MAJOR_EQUAL expr:e2 {: RESULT = new MajorEqualCondition(e1, e2); :}
       | expr:e1 MINOR_MAJOR expr:e2 {: RESULT = new MinorMajorCondition(e1, e2); :}
       | BOOLEAN:b {: RESULT = new BooleanCondition(b); :}
       ;

expr ::= LPARENT expr RPARENT
       | expr SUMA expr
       | expr RESTA expr
       | expr MULTIPLICACION expr
       | expr DIVISION expr
       | INTEGER
       | IDENTIFIER
       ;