import java_cup.runtime.*;
import java.util.*;
import java.io.*;
import entidades.*;

parser code {:
	public static void main (String argv[]) throws Exception {
		parser analizador;
		analizador = new parser(new Yylex(new FileReader(new File("test.txt"))));
		try{
			analizador.parse();
		} catch(SemanticException se){
			System.err.println("Hay un error semántico:\n" + se.getMessage());
		}
	}
:};

terminal PROGRAM, IS, BEGIN, END, VAR, IS_INTEGER, IS_BOOLEAN, READ, WRITE, WHILE, DO, IF, THEN, ELSE, AND, OR, NOT;

terminal ASIGNACION;

terminal MINOR_EQUAL, MINOR, EQUAL, MAJOR, MAJOR_EQUAL;

terminal SUMA, RESTA, MULTIPLICACION, DIVISION;

terminal LPARENT, RPARENT, COMA, SEMI_COLON, COLON;

terminal String IDENTIFIER;
terminal Integer INTEGER;
terminal Boolean BOOLEAN;

non terminal Programa program;
non terminal HashMap<String, Variable> vars;
non terminal HashMap<String, Variable> var;
non terminal HashMap<String, Variable> var_identifier;
non terminal Character type;

non terminal ArrayList<Statement> statements;
non terminal Statement statement;

non terminal AssignStatement asign_statement;
non terminal IfStatement if_statement;
non terminal RWStatement read_statement;
non terminal RWStatement write_statement;
non terminal WhileStatement while_statement;

non terminal Object value;

non terminal Boolean expr_booleana;
non terminal Boolean termino_booleano;

non terminal Integer termino_entero;

non terminal Integer comparation;
non terminal Integer operacion;

precedence left LPARENT, MULTIPLICACION, DIVISION, SUMA, RESTA;


// Es obligatorio que la definición del programa se haga al principio
start with program;

program ::= PROGRAM IDENTIFIER:i 
			IS vars:v
			BEGIN 
				statements:ss	
			END		
			{:
				Programa p = new Programa(i);				
				p.setVariables(v);
				
				// Planificación final del programa
				ArrayList<Statement> tmpSt = new ArrayList<Statement>();
				for(Statement s: ss){
					switch(s.getTipo()){
						case Statement.IF:
							if( ((IfStatement) s).getCondition() )
								tmpSt.addAll(s.getSubStatements());
							else
								tmpSt.addAll(((IfStatement) s).getElseStatements());
							break;
						case Statement.READ:
						case Statement.WRITE:
						case Statement.WHILE:
							// Como no he conseguido hacer que en los terminos booleanos se puedan introducir
							// identificadores de variables, no me queda más remedio que introducir los while sin analizar...
						default:
							tmpSt.add(s);							
							break;				
					}
				}
				
				// Aquí analizo que la asignaciones se hagan bien
				for(Statement s: tmpSt){
					if(s.getTipo() == Statement.ASSIGN) {
						p.setVarValue(((AssignStatement) s).getV());
						p.addStatement(s);
					} else {
						p.addStatement(s);
					}
				}
				
				System.out.println(p);
			:}

;

vars ::= var:v
		{:
			HashMap<String, Variable> hm = new HashMap<String, Variable>();
			for(String s: v.keySet()) {
				if(hm.containsKey(s))
					throw new SemanticException("Variable repetida " + s);
				hm.put(s, v.get(s));
			}
			RESULT = hm;
		:}
		| vars:hm var:v 
		{:
			for(String s: v.keySet()){
				if(hm.containsKey(s))
					throw new SemanticException("Variable repetida " + s);
				hm.put(s, v.get(s));
			}
			RESULT = hm;
		:}
;

var ::= VAR var_identifier:v COLON type:t SEMI_COLON
{:
	// Al principio utilizaba ArrayList, pero habría tenido que comprobar que no se repitiesen los nombres
	// ArrayList<Variable> result = new ArrayList<Variable>();
	HashMap<String, Variable> hm = new HashMap<String, Variable>(); 
	for(String variable: v.keySet()){
	
		if(hm.containsKey(variable))
			throw new SemanticException("Variable repetida " + variable);
			
		if(t == 'i'){
			hm.put(variable, new Int(v.get(variable).getName(), 0));
		} else if(t=='b'){
			hm.put(variable, new Bool(v.get(variable).getName(), true));
		}
	}
	RESULT = hm;
:}
;

var_identifier ::= IDENTIFIER:i 
					{: 
						HashMap<String, Variable> hm = new HashMap<String, Variable>(); 	
						hm.put(i, new Variable(i)); 
						RESULT= hm; 
					:} 
					| var_identifier:hm COMA IDENTIFIER:i 
					{: 
						if(hm.containsKey(i)){
							throw new SemanticException("Variable repetida " + i);
						}
						hm.put(i, new Variable(i)); 
						RESULT = hm;
					:} 
;

type ::=	IS_INTEGER {: RESULT='i'; :} 
			| IS_BOOLEAN {: RESULT='b'; :} 
		;

statements ::=	statement:s
				{:
					ArrayList<Statement> statements = new ArrayList<Statement>();
					statements.add(s);
					RESULT = statements;
				:}
 				| statements:ss statement:s
 
		 		{:
		 			ss.add(s);
		 			RESULT = ss;
		 		:}
			;


statement ::= if_statement:s {: RESULT = s; :} | read_statement:s {: RESULT = s; :}  | write_statement:s {: RESULT = s; :}  | while_statement:s {: RESULT = s; :}  | asign_statement:s {: RESULT = s; :} ;

asign_statement ::= IDENTIFIER:i ASIGNACION value:v SEMI_COLON 
					{: 
						if(v instanceof Boolean)
							RESULT = new AssignStatement(new Bool(i, ((Boolean) v).booleanValue()));
						else if (v instanceof Integer)
							RESULT = new AssignStatement(new Int(i, ((Integer) v).intValue()));
						else
							throw new SemanticException("Variable de tipo desconocido"); 
					:}
				;

value ::= expr_booleana:e {: RESULT = new Boolean(e); :} | termino_entero:t {: RESULT= new Integer(t); :} ;

if_statement ::= 	IF expr_booleana:e THEN statements:ss END IF SEMI_COLON
					{:
						IfStatement s = new IfStatement(e);
						for(Statement aux: ss){
							s.addSubStatement(aux);
						}
						RESULT = s;
					:}
					 | IF expr_booleana:e THEN statements:tss ELSE statements:fss END IF SEMI_COLON
					{:
						IfStatement s = new IfStatement(e);
						for(Statement aux: tss){
							s.addSubStatement(aux);
						}
						for(Statement aux: fss){
							s.addElseStatements(aux);
						}
						RESULT = s;
					:}
			 ;

read_statement ::= READ IDENTIFIER:i SEMI_COLON
				{:
					RESULT = new RWStatement(true, i);
				:}
;
write_statement ::= WRITE IDENTIFIER:i SEMI_COLON
				{:
					RESULT = new RWStatement(false, i);
				:}
;

while_statement ::= WHILE expr_booleana:e DO statements:ss END WHILE SEMI_COLON
					{:
						WhileStatement s = new WhileStatement(e);
						for(Statement aux: ss){
							s.addSubStatement(aux);
						}
						RESULT = s;
					:}
				;

// Como no encuentro la forma de que además de valores  
// explícitos puedan leer valores de variables, (no consigo
// resolver un problema de reducción/desplazamiento para
// poder conservar value) voy a hacer que devuelvan 
// únicamente el valor de las expresiones resueltas

expr_booleana ::= 	termino_booleano:t {: RESULT = t; :}
					| expr_booleana:e AND termino_booleano:t {: RESULT = e && t; :}
					| expr_booleana:e OR termino_booleano:t {: RESULT = e || t; :}
					| expr_booleana:e EQUAL termino_booleano:t {: RESULT = e == t; :}
				;

// Si consigo arreglar mi problema con los identificadores, tendría que introducir esto aquí:
//| IDENTIFIER:i {: RESULT = i; :}
termino_booleano ::= 	BOOLEAN:b {: RESULT = b; :}
						| NOT LPARENT termino_booleano:t RPARENT {: RESULT = !t; :}
						| LPARENT termino_booleano:t RPARENT {: RESULT = t; :}
						| termino_entero:t1 comparation:c termino_entero:t2
						{:
							switch(c){
								case 0:
									RESULT = t1 <= t2;
									break;
								case 1:
									RESULT = t1 < t2;
									break;
								case 2:
									RESULT = t1 == t2;
									break;
								case 3:
									RESULT = t1 > t2;
									break;
								case 4:
									RESULT = t1 >= t2;
									break;
							}					
						:}
					;
						
termino_entero ::= 	INTEGER:i {: RESULT = i; :}
					| LPARENT termino_entero:i RPARENT {: RESULT = i; :}
					| termino_entero:t operacion:o INTEGER:i 
					{:
						switch(o){
							case 0:
								RESULT = t + i;
								break;
							case 1:
								RESULT = t - i;
								break;
							case 2:
								RESULT = t * i;
								break;
							case 3:
								RESULT = t / i;
								break;
						}
					:}
			;
				

comparation ::= MINOR_EQUAL  {: RESULT = 0; :} 
				| MINOR {: RESULT = 1; :} 
				| EQUAL {: RESULT = 2; :} 
				| MAJOR {: RESULT = 3; :} 
				| MAJOR_EQUAL {: RESULT = 4; :} ;

operacion ::= 	SUMA {: RESULT = 0; :} 
				| RESTA {: RESULT = 1; :} 
				| MULTIPLICACION {: RESULT = 2; :} 
				| DIVISION {: RESULT = 3; :};

















